
#include "plat.h"
#include "osal.h"

#include "precomp.h"

//static unsigned int g_iftype = 0;
static struct timer_list rst_timer;

int sc_plt_set_monitor_chan(struct chan_info *info, void *priv)
{
	/* start monitor mode, refer to priv_driver_set_monitor() */
	P_ADAPTER_T pAd = (P_ADAPTER_T)priv;
	WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;
	PARAM_CUSTOM_MONITOR_SET_STRUCT_T rMonitorSetInfo;
	UINT_32 u4BufLen = 0;
	BOOLEAN fgEnable = TRUE;
	UINT_8 ucPriChannel = 0;
	UINT_8 ucChannelWidth = 0;
	UINT_8 ucExt = 0;
	UINT_8 ucSco = 0;
	UINT_8 ucChannelS1 = 0;
	UINT_8 ucChannelS2 = 0;
	BOOLEAN fgError = FALSE;

	DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] fgIsEnableMon=%d, fgEnable=%d!\n",
		pAd->prGlueInfo->fgIsEnableMon, fgEnable));

	if (pAd->prGlueInfo->fgIsEnableMon != fgEnable) {
		DBGPRINT(ELIAN_DBG_WARN, ("[MSC] schedule_work monWork! fgEnable = %d\n", fgEnable));
		pAd->prGlueInfo->fgIsEnableMon = fgEnable;
		schedule_work(&pAd->prGlueInfo->monWork);
	}

	ucPriChannel = info->chan_id;

	switch (info->chan_width) {
	case 160:
		ucChannelWidth = (UINT_8) CW_160MHZ;
		ucSco = (UINT_8) CHNL_EXT_SCN;

		if (ucPriChannel >= 36 && ucPriChannel <= 64)
			ucChannelS2 = 50;
		else if (ucPriChannel >= 100 && ucPriChannel <= 128)
			ucChannelS2 = 114;
		else
			fgError = TRUE;
		break;

	case 80:
		ucChannelWidth = (UINT_8) CW_80MHZ;
		ucSco = (UINT_8) CHNL_EXT_SCN;

		if (ucPriChannel >= 36 && ucPriChannel <= 48)
			ucChannelS1 = 42;
		else if (ucPriChannel >= 52 && ucPriChannel <= 64)
			ucChannelS1 = 58;
		else if (ucPriChannel >= 100 && ucPriChannel <= 112)
			ucChannelS1 = 106;
		else if (ucPriChannel >= 116 && ucPriChannel <= 128)
			ucChannelS1 = 122;
		else if (ucPriChannel >= 132 && ucPriChannel <= 144)
			ucChannelS1 = 138;
		else if (ucPriChannel >= 149 && ucPriChannel <= 161)
			ucChannelS1 = 155;
		else
			fgError = TRUE;
		break;

	case 40:
		ucChannelWidth = (UINT_8) CW_20_40MHZ;
		if(ucPriChannel == 1 || ucPriChannel == 36)
			ucExt = 1;

		ucSco = (ucExt) ? (UINT_8) CHNL_EXT_SCA : (UINT_8) CHNL_EXT_SCB;
		break;

	case 20:
		ucChannelWidth = (UINT_8) CW_20_40MHZ;
		ucSco = (UINT_8) CHNL_EXT_SCN;
		break;

	default:
		fgError = TRUE;
		break;
	}

	if (fgError) {
		DBGPRINT(ELIAN_DBG_ERROR, ("[MSC] Monitor channel error!\n"));
		return -1;
	}

	kalMemZero(&rMonitorSetInfo, sizeof(rMonitorSetInfo));
	rMonitorSetInfo.ucEnable = fgEnable;
	rMonitorSetInfo.ucPriChannel = ucPriChannel;
	rMonitorSetInfo.ucSco = ucSco;
	rMonitorSetInfo.ucChannelWidth = ucChannelWidth;
	rMonitorSetInfo.ucChannelS1 = ucChannelS1;
	rMonitorSetInfo.ucChannelS2 = ucChannelS2;

	DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] PriChannel=%d, Sco=%d, ChannelWidth=%d, ChannelS1=%d, ChannelS2=%d!\n",
		ucPriChannel, ucSco, ucChannelWidth, ucChannelS1, ucChannelS2));

	rStatus = kalIoctl(pAd->prGlueInfo,
			wlanoidSetMonitor,
			&rMonitorSetInfo, sizeof(rMonitorSetInfo), FALSE, FALSE, TRUE, FALSE, &u4BufLen);

	if(rStatus == WLAN_STATUS_SUCCESS) {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] Set monitor mode success!\n"));
		return 0;
	} else {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] Set monitor mode fail %d!\n", rStatus));
		return -2;
	}

	return 0;
}

int sc_plt_enter_monitor_mode(struct monitor_info *info, void *priv)
{
	/* start monitor mode, refer to priv_driver_set_monitor() */
	P_ADAPTER_T pAd = (P_ADAPTER_T)priv;
	WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;
	PARAM_CUSTOM_MONITOR_SET_STRUCT_T rMonitorSetInfo;
	UINT_32 u4BufLen = 0;
	BOOLEAN fgEnable = TRUE;
	UINT_8 ucPriChannel = 0;
	UINT_8 ucChannelWidth = 0;
	UINT_8 ucExt = 0;
	UINT_8 ucSco = 0;
	UINT_8 ucChannelS1 = 0;
	UINT_8 ucChannelS2 = 0;
	BOOLEAN fgError = FALSE;

	DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] fgIsEnableMon=%d, fgEnable=%d!\n",
		pAd->prGlueInfo->fgIsEnableMon, fgEnable));

	if (pAd->prGlueInfo->fgIsEnableMon != fgEnable) {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] schedule_work monWork!\n"));
		pAd->prGlueInfo->fgIsEnableMon = fgEnable;
		schedule_work(&pAd->prGlueInfo->monWork);
	}

	ucPriChannel = info->chl_info.chan_id;

	switch (info->chl_info.chan_width) {
	case 160:
		ucChannelWidth = (UINT_8) CW_160MHZ;
		ucSco = (UINT_8) CHNL_EXT_SCN;

		if (ucPriChannel >= 36 && ucPriChannel <= 64)
			ucChannelS2 = 50;
		else if (ucPriChannel >= 100 && ucPriChannel <= 128)
			ucChannelS2 = 114;
		else
			fgError = TRUE;
		break;

	case 80:
		ucChannelWidth = (UINT_8) CW_80MHZ;
		ucSco = (UINT_8) CHNL_EXT_SCN;

		if (ucPriChannel >= 36 && ucPriChannel <= 48)
			ucChannelS1 = 42;
		else if (ucPriChannel >= 52 && ucPriChannel <= 64)
			ucChannelS1 = 58;
		else if (ucPriChannel >= 100 && ucPriChannel <= 112)
			ucChannelS1 = 106;
		else if (ucPriChannel >= 116 && ucPriChannel <= 128)
			ucChannelS1 = 122;
		else if (ucPriChannel >= 132 && ucPriChannel <= 144)
			ucChannelS1 = 138;
		else if (ucPriChannel >= 149 && ucPriChannel <= 161)
			ucChannelS1 = 155;
		else
			fgError = TRUE;
		break;

	case 40:
		ucChannelWidth = (UINT_8) CW_20_40MHZ;
		ucSco = (ucExt) ? (UINT_8) CHNL_EXT_SCA : (UINT_8) CHNL_EXT_SCB;
		break;

	case 20:
		ucChannelWidth = (UINT_8) CW_20_40MHZ;
		ucSco = (UINT_8) CHNL_EXT_SCN;
		break;

	default:
		fgError = TRUE;
		break;
	}

	if (fgError) {
		DBGPRINT(ELIAN_DBG_ERROR, ("[MSC] Monitor channel error!\n"));
		return -1;
	}

	kalMemZero(&rMonitorSetInfo, sizeof(rMonitorSetInfo));
	rMonitorSetInfo.ucEnable = fgEnable;
	rMonitorSetInfo.ucPriChannel = ucPriChannel;
	rMonitorSetInfo.ucSco = ucSco;
	rMonitorSetInfo.ucChannelWidth = ucChannelWidth;
	rMonitorSetInfo.ucChannelS1 = ucChannelS1;
	rMonitorSetInfo.ucChannelS2 = ucChannelS2;

	DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] PriChannel=%d, Sco=%d, ChannelWidth=%d, ChannelS1=%d, ChannelS2=%d!\n",
		ucPriChannel, ucSco, ucChannelWidth, ucChannelS1, ucChannelS2));

	rStatus = kalIoctl(pAd->prGlueInfo,
			wlanoidSetMonitor,
			&rMonitorSetInfo, sizeof(rMonitorSetInfo), FALSE, FALSE, TRUE, FALSE, &u4BufLen);
	if(rStatus == WLAN_STATUS_SUCCESS) {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] Set monitor mode success!\n"));
		return 0;
	} else {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] Set monitor mode fail %d!\n", rStatus));
		return -2;
	}

	return 0;
}

int sc_plt_leave_monitor_mode(void *priv)
{
	/* stop monitor mode, refer to priv_driver_set_monitor() */
	P_ADAPTER_T pAd = (P_ADAPTER_T)priv;
	WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;
	PARAM_CUSTOM_MONITOR_SET_STRUCT_T rMonitorSetInfo;
	UINT_32 u4BufLen = 0;
	BOOLEAN fgEnable = FALSE;

	if (pAd->prGlueInfo->fgIsEnableMon != fgEnable) {
		pAd->prGlueInfo->fgIsEnableMon = fgEnable;
		schedule_work(&pAd->prGlueInfo->monWork);
	}

	//TODO leave monitor mode need to set channel or not?
	kalMemZero(&rMonitorSetInfo, sizeof(rMonitorSetInfo));
	rMonitorSetInfo.ucEnable = fgEnable;
	rMonitorSetInfo.ucPriChannel = 1;
	rMonitorSetInfo.ucSco = 0;
	rMonitorSetInfo.ucChannelWidth = 0;
	rMonitorSetInfo.ucChannelS1 = 0;
	rMonitorSetInfo.ucChannelS2 = 0;

	DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] leave monitor mode!\n"));

	rStatus = kalIoctl(pAd->prGlueInfo,
			wlanoidSetMonitor,
			&rMonitorSetInfo, sizeof(rMonitorSetInfo), FALSE, FALSE, TRUE, FALSE, &u4BufLen);
	if(rStatus == WLAN_STATUS_SUCCESS) {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] leave monitor mode success!\n"));
		return 0;
	} else {
		DBGPRINT(ELIAN_DBG_DEBUG, ("[MSC] leave monitor mode fail %d!\n", rStatus));
		return -2;
	}

	return 0;
}

char *sc_plt_get_la(void *priv)
{
	P_ADAPTER_T pAd = (P_ADAPTER_T)priv;
	DBGPRINT(ELIAN_DBG_WARN,("[MSC] get local address %p : %x:%x:%x:%x:%x:%x\n",
		priv, pAd->rWifiVar.aucMacAddress[0]&0xff, pAd->rWifiVar.aucMacAddress[1]&0xff,
		pAd->rWifiVar.aucMacAddress[2]&0xff, pAd->rWifiVar.aucMacAddress[3]&0xff,
		pAd->rWifiVar.aucMacAddress[4]&0xff, pAd->rWifiVar.aucMacAddress[5]&0xff));
	return (char*)pAd->aucMacAddress;
}

/* AES definition & structure */
#define AES_STATE_ROWS 4	/* Block size: 4*4*8 = 128 bits */
#define AES_STATE_COLUMNS 4
#define AES_BLOCK_SIZES AES_STATE_ROWS*AES_STATE_COLUMNS
#define AES_KEY_ROWS 4
#define AES_KEY_COLUMNS 8	/*Key length: 4*{4,6,8}*8 = 128, 192, 256 bits */
#define AES_KEY128_LENGTH 16
#define AES_KEY192_LENGTH 24
#define AES_KEY256_LENGTH 32
#define AES_CBC_IV_LENGTH 16
typedef struct {
	unsigned char State[AES_STATE_ROWS][AES_STATE_COLUMNS];
	unsigned char KeyWordExpansion[AES_KEY_ROWS][AES_KEY_ROWS * ((AES_KEY256_LENGTH >> 2) + 6 + 1)];
} AES_CTX_STRUC, *PAES_CTX_STRUC;

/* The value given by [x^(i-1),{00},{00},{00}], with x^(i-1) being powers of x in the field GF(2^8). */
static const unsigned int aes_rcon[] = {
	0x00000000, 0x01000000, 0x02000000, 0x04000000,
	0x08000000, 0x10000000, 0x20000000, 0x40000000,
	0x80000000, 0x1B000000, 0x36000000
};

static const unsigned char aes_sbox_enc[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,	/* 0 */
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,	/* 1 */
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,	/* 2 */
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,	/* 3 */
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,	/* 4 */
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,	/* 5 */
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,	/* 6 */
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,	/* 7 */
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,	/* 8 */
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,	/* 9 */
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,	/* a */
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,	/* b */
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,	/* c */
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,	/* d */
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,	/* e */
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,	/* f */
};

static const unsigned char aes_sbox_dec[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,	/* 0 */
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,	/* 1 */
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,	/* 2 */
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,	/* 3 */
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,	/* 4 */
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,	/* 5 */
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,	/* 6 */
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,	/* 7 */
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,	/* 8 */
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,	/* 9 */
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,	/* a */
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,	/* b */
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,	/* c */
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,	/* d */
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,	/* e */
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,	/* f */
};

/* ArrayIndex*{02} */
static const unsigned char aes_mul_2[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,	/* 0 */
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,	/* 1 */
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,	/* 2 */
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,	/* 3 */
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,	/* 4 */
	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,	/* 5 */
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,	/* 6 */
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,	/* 7 */
	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,	/* 8 */
	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,	/* 9 */
	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,	/* a */
	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,	/* b */
	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,	/* c */
	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,	/* d */
	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,	/* e */
	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,	/* f */
};

/* ArrayIndex*{03} */
static const unsigned char aes_mul_3[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,	/* 0 */
	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,	/* 1 */
	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,	/* 2 */
	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,	/* 3 */
	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,	/* 4 */
	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,	/* 5 */
	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,	/* 6 */
	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,	/* 7 */
	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,	/* 8 */
	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,	/* 9 */
	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,	/* a */
	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,	/* b */
	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,	/* c */
	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,	/* d */
	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,	/* e */
	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,	/* f */
};

/* ArrayIndex*{09} */
static const unsigned char aes_mul_9[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,	/* 0 */
	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,	/* 1 */
	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,	/* 2 */
	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,	/* 3 */
	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,	/* 4 */
	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,	/* 5 */
	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,	/* 6 */
	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,	/* 7 */
	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,	/* 8 */
	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,	/* 9 */
	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,	/* a */
	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,	/* b */
	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,	/* c */
	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,	/* d */
	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,	/* e */
	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,	/* f */
};

/* ArrayIndex*{0b} */
static const unsigned char aes_mul_b[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,	/* 0 */
	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,	/* 1 */
	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,	/* 2 */
	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,	/* 3 */
	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,	/* 4 */
	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,	/* 5 */
	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,	/* 6 */
	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,	/* 7 */
	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,	/* 8 */
	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,	/* 9 */
	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,	/* a */
	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,	/* b */
	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,	/* c */
	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,	/* d */
	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,	/* e */
	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,	/* f */
};

/* ArrayIndex*{0d} */
static const unsigned char aes_mul_d[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,	/* 0 */
	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,	/* 1 */
	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,	/* 2 */
	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,	/* 3 */
	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,	/* 4 */
	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,	/* 5 */
	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,	/* 6 */
	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,	/* 7 */
	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,	/* 8 */
	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,	/* 9 */
	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,	/* a */
	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,	/* b */
	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,	/* c */
	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,	/* d */
	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,	/* e */
	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,	/* f */
};

/* ArrayIndex*{0e} */
static const unsigned char aes_mul_e[] = {
	/*  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f    */
	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,	/* 0 */
	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,	/* 1 */
	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,	/* 2 */
	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,	/* 3 */
	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,	/* 4 */
	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,	/* 5 */
	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,	/* 6 */
	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,	/* 7 */
	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,	/* 8 */
	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,	/* 9 */
	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,	/* a */
	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,	/* b */
	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,	/* c */
	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,	/* d */
	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,	/* e */
	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,	/* f */
};
/*
========================================================================
Routine Description:
    AES key expansion (key schedule)

Arguments:
    Key              Cipher key, it may be 16, 24, or 32 bytes (128, 192, or 256 bits)
    KeyLength        The length of cipher key in bytes
    paes_ctx         Pointer to AES_CTX_STRUC

Return Value:
    paes_ctx         Retrun the KeyWordExpansion of AES_CTX_STRUC

Note:
    Pseudo code for key expansion
    ------------------------------------------
       Nk = (key length/4);

       while (i < Nk)
	   KeyWordExpansion[i] = word(key[4*i], key[4*i + 1], key[4*i + 2], key[4*i + 3]);
	   i++;
       end while

       while (i < ((key length/4 + 6 + 1)*4) )
	   temp = KeyWordExpansion[i - 1];
	   if (i % Nk ==0)
	       temp = SubWord(RotWord(temp)) ^ Rcon[i/Nk];
	   else if ((Nk > 6) && (i % 4 == 4))
	       temp = SubWord(temp);
	   end if

	   KeyWordExpansion[i] = KeyWordExpansion[i - Nk]^ temp;
	   i++;
       end while
========================================================================
*/
void RT_AES_KeyExpansion(unsigned char Key[], unsigned int KeyLength, AES_CTX_STRUC * paes_ctx)
{
	unsigned int KeyIndex = 0;
	unsigned int NumberOfWordOfKey, NumberOfWordOfKeyExpansion;
	unsigned char TempWord[AES_KEY_ROWS], Temp;
	unsigned int Temprcon;

	NumberOfWordOfKey = KeyLength >> 2;
	while (KeyIndex < NumberOfWordOfKey) {
		paes_ctx->KeyWordExpansion[0][KeyIndex] = Key[4 * KeyIndex];
		paes_ctx->KeyWordExpansion[1][KeyIndex] = Key[4 * KeyIndex + 1];
		paes_ctx->KeyWordExpansion[2][KeyIndex] = Key[4 * KeyIndex + 2];
		paes_ctx->KeyWordExpansion[3][KeyIndex] = Key[4 * KeyIndex + 3];
		KeyIndex++;
	}

	NumberOfWordOfKeyExpansion = ((unsigned int) AES_KEY_ROWS) * ((KeyLength >> 2) + 6 + 1);
	while (KeyIndex < NumberOfWordOfKeyExpansion) {
		TempWord[0] = paes_ctx->KeyWordExpansion[0][KeyIndex - 1];
		TempWord[1] = paes_ctx->KeyWordExpansion[1][KeyIndex - 1];
		TempWord[2] = paes_ctx->KeyWordExpansion[2][KeyIndex - 1];
		TempWord[3] = paes_ctx->KeyWordExpansion[3][KeyIndex - 1];
		if ((KeyIndex % NumberOfWordOfKey) == 0) {
			Temprcon = aes_rcon[KeyIndex / NumberOfWordOfKey];
			Temp = aes_sbox_enc[TempWord[1]] ^ ((Temprcon >> 24) & 0xff);
			TempWord[1] = aes_sbox_enc[TempWord[2]] ^ ((Temprcon >> 16) & 0xff);
			TempWord[2] = aes_sbox_enc[TempWord[3]] ^ ((Temprcon >> 8) & 0xff);
			TempWord[3] = aes_sbox_enc[TempWord[0]] ^ ((Temprcon) & 0xff);
			TempWord[0] = Temp;
		} else if ((NumberOfWordOfKey > 6) && ((KeyIndex % NumberOfWordOfKey) == 4)) {
			Temp = aes_sbox_enc[TempWord[0]];
			TempWord[1] = aes_sbox_enc[TempWord[1]];
			TempWord[2] = aes_sbox_enc[TempWord[2]];
			TempWord[3] = aes_sbox_enc[TempWord[3]];
			TempWord[0] = Temp;
		}
		paes_ctx->KeyWordExpansion[0][KeyIndex] =
		    paes_ctx->KeyWordExpansion[0][KeyIndex - NumberOfWordOfKey] ^ TempWord[0];
		paes_ctx->KeyWordExpansion[1][KeyIndex] =
		    paes_ctx->KeyWordExpansion[1][KeyIndex - NumberOfWordOfKey] ^ TempWord[1];
		paes_ctx->KeyWordExpansion[2][KeyIndex] =
		    paes_ctx->KeyWordExpansion[2][KeyIndex - NumberOfWordOfKey] ^ TempWord[2];
		paes_ctx->KeyWordExpansion[3][KeyIndex] =
		    paes_ctx->KeyWordExpansion[3][KeyIndex - NumberOfWordOfKey] ^ TempWord[3];
		KeyIndex++;
	}
}

/*
========================================================================
Routine Description:
    AES decryption

Arguments:
    CipherBlock      The block of cipher text, 16 bytes(128 bits) each block
    CipherBlockSize  The length of block of cipher text in bytes
    Key              Cipher key, it may be 16, 24, or 32 bytes (128, 192, or 256 bits)
    KeyLength        The length of cipher key in bytes
    PlainBlockSize   The length of allocated plain block in bytes

Return Value:
    PlainBlock       Return plain text
    PlainBlockSize  Return the length of real used plain block in bytes

Note:
    Reference to FIPS-PUB 197
    1. Check if block size is 16 bytes(128 bits) and if key length is 16, 24, or 32 bytes(128, 192, or 256 bits)
    2. Transfer the cipher block to state block
    3. Main decryption rounds
    4. Transfer the state block to plain block
    ------------------------------------------
       NumberOfRound = (key length / 4) + 6;
       state block = cipher block;

       AddRoundKey(state block, key);
       for round = NumberOfRound to 1
	   InvSubBytes(state block)
	   InvShiftRows(state block)
	   InvMixColumns(state block)
	   AddRoundKey(state block, key);
       end for

       InvSubBytes(state block)
       InvShiftRows(state block)
       AddRoundKey(state block, key);

       plain block = state block;
========================================================================
*/
void RT_AES_Decrypt(unsigned char CipherBlock[],
		unsigned int CipherBlockSize,
		unsigned char Key[],
		unsigned int KeyLength, unsigned char PlainBlock[], unsigned int *PlainBlockSize)
{
	AES_CTX_STRUC *paes_ctx = NULL;
	unsigned int RowIndex, ColumnIndex;
	unsigned int RoundIndex, NumberOfRound = 0;
	unsigned char Temp, Row0, Row1, Row2, Row3;

	/*
	 * 1. Check if block size is 16 bytes(128 bits) and if key length is 16, 24, or 32 bytes(128, 192, or 256 bits)
	 */
	if (*PlainBlockSize < AES_BLOCK_SIZES) {
		DBGPRINT(ELIAN_DBG_DEBUG,
			 ("RT_AES_Decrypt: plain block size is %d bytes, it must be %d bytes(128 bits).\n",
			  *PlainBlockSize, AES_BLOCK_SIZES));
		return;
	}
	if ((KeyLength != AES_KEY128_LENGTH) && (KeyLength != AES_KEY192_LENGTH)
	    && (KeyLength != AES_KEY256_LENGTH)) {
		DBGPRINT(ELIAN_DBG_DEBUG,
			 ("RT_AES_Decrypt: key length is %d bytes, it must be %d, %d, or %d bytes(128, 192, or 256 bits).\n",
			  KeyLength, AES_KEY128_LENGTH, AES_KEY192_LENGTH, AES_KEY256_LENGTH));
		return;
	}
	if (CipherBlockSize != AES_BLOCK_SIZES) {
		DBGPRINT(ELIAN_DBG_DEBUG,
			 ("RT_AES_Decrypt: cipher block size is %d bytes, it must be %d bytes(128 bits).\n",
			  CipherBlockSize, AES_BLOCK_SIZES));
		return;
	}

	/* allocate memory */
	paes_ctx = kalMemAlloc(sizeof(AES_CTX_STRUC), PHY_MEM_TYPE);
	if (paes_ctx == NULL) {
		DBGPRINT(ELIAN_DBG_DEBUG, ("%s: Allocate memory fail!!!\n", __func__));
		return;
	}

	/*
	 * 2. Transfer the cipher block to state block
	 */
	for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
		for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
			paes_ctx->State[RowIndex][ColumnIndex] =
			    CipherBlock[RowIndex + 4 * ColumnIndex];

	/*
	 *  3. Main decryption rounds
	 */
	RT_AES_KeyExpansion(Key, KeyLength, paes_ctx);
	NumberOfRound = (KeyLength >> 2) + 6;

	/* AES_AddRoundKey */
	RoundIndex = NumberOfRound;
	for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
		for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
			paes_ctx->State[RowIndex][ColumnIndex] ^=
			    paes_ctx->KeyWordExpansion[RowIndex][(RoundIndex *
								  ((unsigned int) AES_STATE_COLUMNS)) +
								 ColumnIndex];

	for (RoundIndex = (NumberOfRound - 1); RoundIndex > 0; RoundIndex--) {
		/* AES_InvShiftRows */
		Temp = paes_ctx->State[1][3];
		paes_ctx->State[1][3] = paes_ctx->State[1][2];
		paes_ctx->State[1][2] = paes_ctx->State[1][1];
		paes_ctx->State[1][1] = paes_ctx->State[1][0];
		paes_ctx->State[1][0] = Temp;
		Temp = paes_ctx->State[2][0];
		paes_ctx->State[2][0] = paes_ctx->State[2][2];
		paes_ctx->State[2][2] = Temp;
		Temp = paes_ctx->State[2][1];
		paes_ctx->State[2][1] = paes_ctx->State[2][3];
		paes_ctx->State[2][3] = Temp;
		Temp = paes_ctx->State[3][0];
		paes_ctx->State[3][0] = paes_ctx->State[3][1];
		paes_ctx->State[3][1] = paes_ctx->State[3][2];
		paes_ctx->State[3][2] = paes_ctx->State[3][3];
		paes_ctx->State[3][3] = Temp;

		/* AES_InvSubBytes */
		for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
			for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
				paes_ctx->State[RowIndex][ColumnIndex] =
				    aes_sbox_dec[paes_ctx->State[RowIndex][ColumnIndex]];

		/* AES_AddRoundKey */
		for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
			for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
				paes_ctx->State[RowIndex][ColumnIndex] ^=
				    paes_ctx->KeyWordExpansion[RowIndex][(RoundIndex * ((unsigned int)
											AES_STATE_COLUMNS))
									 + ColumnIndex];

		/* AES_InvMixColumns */
		for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++) {
			Row0 = paes_ctx->State[0][ColumnIndex];
			Row1 = paes_ctx->State[1][ColumnIndex];
			Row2 = paes_ctx->State[2][ColumnIndex];
			Row3 = paes_ctx->State[3][ColumnIndex];
			paes_ctx->State[0][ColumnIndex] =
			    aes_mul_e[Row0] ^ aes_mul_b[Row1] ^ aes_mul_d[Row2] ^ aes_mul_9[Row3];
			paes_ctx->State[1][ColumnIndex] =
			    aes_mul_9[Row0] ^ aes_mul_e[Row1] ^ aes_mul_b[Row2] ^ aes_mul_d[Row3];
			paes_ctx->State[2][ColumnIndex] =
			    aes_mul_d[Row0] ^ aes_mul_9[Row1] ^ aes_mul_e[Row2] ^ aes_mul_b[Row3];
			paes_ctx->State[3][ColumnIndex] =
			    aes_mul_b[Row0] ^ aes_mul_d[Row1] ^ aes_mul_9[Row2] ^ aes_mul_e[Row3];
		}
	}

	/* AES_InvShiftRows */
	Temp = paes_ctx->State[1][3];
	paes_ctx->State[1][3] = paes_ctx->State[1][2];
	paes_ctx->State[1][2] = paes_ctx->State[1][1];
	paes_ctx->State[1][1] = paes_ctx->State[1][0];
	paes_ctx->State[1][0] = Temp;
	Temp = paes_ctx->State[2][0];
	paes_ctx->State[2][0] = paes_ctx->State[2][2];
	paes_ctx->State[2][2] = Temp;
	Temp = paes_ctx->State[2][1];
	paes_ctx->State[2][1] = paes_ctx->State[2][3];
	paes_ctx->State[2][3] = Temp;
	Temp = paes_ctx->State[3][0];
	paes_ctx->State[3][0] = paes_ctx->State[3][1];
	paes_ctx->State[3][1] = paes_ctx->State[3][2];
	paes_ctx->State[3][2] = paes_ctx->State[3][3];
	paes_ctx->State[3][3] = Temp;
	/* AES_InvSubBytes */
	for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
		for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
			paes_ctx->State[RowIndex][ColumnIndex] =
			    aes_sbox_dec[paes_ctx->State[RowIndex][ColumnIndex]];
	/* AES_AddRoundKey */
	for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
		for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
			paes_ctx->State[RowIndex][ColumnIndex] ^=
			    paes_ctx->KeyWordExpansion[RowIndex][(RoundIndex *
								  ((unsigned int) AES_STATE_COLUMNS)) +
								 ColumnIndex];

	/*
	 * 4. Transfer the state block to plain block
	 */
	for (RowIndex = 0; RowIndex < AES_STATE_ROWS; RowIndex++)
		for (ColumnIndex = 0; ColumnIndex < AES_STATE_COLUMNS; ColumnIndex++)
			PlainBlock[RowIndex + 4 * ColumnIndex] =
			    paes_ctx->State[RowIndex][ColumnIndex];

	*PlainBlockSize = ((unsigned int) AES_STATE_ROWS) * ((unsigned int) AES_STATE_COLUMNS);

	if (paes_ctx != NULL)
		kalMemFree(paes_ctx, PHY_MEM_TYPE, sizeof(AES_CTX_STRUC));
}

void sc_plt_aes128_decrypt(unsigned char *cipher_blk, unsigned int cipher_blk_size,
				unsigned char *key, unsigned int key_len,
				unsigned char *plain_blk, unsigned int *plain_blk_size)
{
	RT_AES_Decrypt(cipher_blk, cipher_blk_size, key, key_len, plain_blk, plain_blk_size);
}

void sc_plt_add_timer(struct etimer *p)
{
	init_timer(&rst_timer);
	rst_timer.expires = jiffies + p->expires * HZ;
	rst_timer.data = p->data;
	rst_timer.function = p->func;
	return add_timer(&rst_timer);
}

int sc_plt_del_timer(struct etimer *p)
{
	return del_timer(&rst_timer);
}

int sc_plt_get_cur_channel(void *priv)
{
	int cur_chl = 0;
	P_ADAPTER_T pAd = (P_ADAPTER_T)priv;

	cur_chl = pAd->rWifiVar.arBssInfo[NETWORK_TYPE_AIS_INDEX].ucPrimaryChannel;

	return cur_chl;
}

